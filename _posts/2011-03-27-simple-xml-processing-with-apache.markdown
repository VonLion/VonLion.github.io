---
layout: post
title: "Simple XML processing with Apache Cocoon 3"
date: 2011-03-27
comments: true

categories:
---

It's been a while since I've last used <a href="http://cocoon.apache.org/">Apache Cocoon</a>. I can still remember the day that I was using Cocoon for doing all my web development projects. My first introduction with Cocoon was when I started at <a href="http://www.onehippo.com/">Hippo</a> about 8 years ago. In comparison to other frameworks, I sometimes miss the simplicity of the Cocoon pipeline concept when I have to work with XML. Especially processing larger XML files is pain in most IDE's.

The Cocoon team has been working on <a href="http://cocoon.apache.org/3.0/index.html">Cocoon 3</a> for a while now, so I wanted to give it a try. Having worked with both Cocoon 2.1 and 2.2, version 3 is created with two new goals in mind: <br /><ul><li>slim down the framework</li><li>make it easier to use/combine with other frameworks</li></ul><br />From what I've seen so far, this results in that you can now do a lot more with just plain Java. Where you would need to use a sitemap XML file before, you can now do a lot with just a few lines of Java. Even though Cocoon 3 is still in alpha stage, it already looks quite promising. <br /><br /><h2>Getting started</h2>To be able to process XML with Cocoon 3, all we need are the following two maven dependencies.<br /><br /><pre class="brush:xml">&lt;dependencies&gt;<br />  &lt;dependency&gt;<br />    &lt;groupId&gt;org.apache.cocoon.pipeline&lt;/groupId&gt;<br />    &lt;artifactId&gt;cocoon-pipeline&lt;/artifactId&gt;<br />    &lt;version&gt;3.0.0-alpha-2&lt;/version&gt;<br />  &lt;/dependency&gt;<br /><br />  &lt;dependency&gt;<br />    &lt;groupId&gt;org.apache.cocoon.sax&lt;/groupId&gt;<br />    &lt;artifactId&gt;cocoon-sax&lt;/artifactId&gt;<br />    &lt;version&gt;3.0.0-alpha-2&lt;/version&gt;<br />  &lt;/dependency&gt;<br />&lt;/dependencies&gt;<br /></pre><br />These dependencies drag in just two more dependencies (commons-logging and cocoon-xml, so the end result will be quite small, which is really nice compared to for instance Cocoon 2.1, which came with quite some baggage.<br /><br /><h3>The code</h3>Now let's have a look at some Java code. To play around with Cocoon 3, I'm going to use the RSS feed of this blog. Let's see how Cocoon's new Java based coding works. To be able to process the XML result of the RSS feed, I've created the <i>RSSFeedInfoGenerator</i>. The <i>RSSFeedInfoGenerator</i> is a simple class that will parse a provided RSS feed url.<br /><br /><pre class="brush:java">/**<br /> * RSS Feed info generator<br /> */<br />public class RSSFeedInfoGenerator {<br /><br />  private static final String DEFAULT_RSS_URL = "http://blog.jeroenreijn.com/feeds/posts/default?alt=rss";<br /><br />  public static void main(String[] args) {<br />    RSSParser parser = new RSSParser();<br />    if(args!=null &amp;&amp; args.length &gt; 0) {<br />      parser.setFeedURL(args[0]);<br />    } else {<br />      parser.setFeedURL(DEFAULT_RSS_URL);<br />    }<br />    parser.parse();<br />  }<br />}<br /></pre><br />So now there is a start from which we can actually build the RSS parser and use Cocoon for processing the XML. Now let's take a look at the actual <i>RSSParser</i>.<br /><br /><pre class="brush:java">/**<br /> * Rss parser that uses Cocoon 3 pipelines for generating<br /> * and transforming the RSS feed to a simple XML response.<br /> */<br />public class RSSParser {<br /><br />  private static final Log LOG = LogFactory.getLog(RSSParser.class);<br />  private String feedURL;<br /><br />  /**<br />   * Parse the provided feed URL and generate the Feed INFO.<br />   */<br />  public void parse() {<br />    try {<br />       Pipeline&lt;SAXPipelineComponent&gt; pipeline = new NonCachingPipeline&lt;SAXPipelineComponent&gt;();<br />       XSLTTransformer xsltTransformer = new XSLTTransformer(this.getClass().getResource("simplify-rss.xsl"));<br /><br />       pipeline.addComponent(new XMLGenerator(new URL(getFeedURL())));<br />       pipeline.addComponent(new CleaningTransformer());<br />       pipeline.addComponent(xsltTransformer);<br />       pipeline.addComponent(new XMLSerializer().setIndent(true));<br />       pipeline.setup(System.out);<br />       pipeline.execute();<br /><br />    } catch (MalformedURLException e) {<br />       LOG.error("An exception occurred while parsing the RSS URL: " + e.getMessage());<br />    } catch (FileNotFoundException e) {<br />       LOG.error("An exception occurred while parsing the RSS URL: " + e.getMessage());<br />    } catch (Exception e) {<br />       LOG.error("An exception occurred trying to parse the RSS feed: " + e.getMessage());<br />    }<br />  }<br /><br />  public String getFeedURL() {<br />    return feedURL;<br />  }<br /><br />  public void setFeedURL(final String feedURL) {<br />    this.feedURL = feedURL;<br />  }<br />}<br /><br /></pre><br />As you can see I first created a Pipeline, which in this case is SAX based. In a Cocoon pipeline you can add multiple components, so we add a Generator, two Transformers and a Serializer. The normal XML version of the RSS feed is quite large, so to make the XML result for this example quite small, we use an XSL template to remove all but the <i>title</i> and <i>lastBuildDate</i> from the RSS feed. Let's have a look at the XSL template. <br /><br /><pre class="brush:xml">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;<br />  &lt;xsl:output indent="yes"/&gt;<br /><br />  &lt;xsl:template match="rss"&gt;<br />    &lt;info&gt;<br />      &lt;xsl:copy-of select="channel/title"/&gt;<br />      &lt;xsl:copy-of select="channel/lastBuildDate"/&gt;<br />    &lt;/info&gt;<br />  &lt;/xsl:template&gt;<br /><br />  &lt;xsl:template match="@*|node()|text()|comment()|processing-instruction()" priority="-1"&gt;<br />    &lt;xsl:copy&gt;<br />      &lt;xsl:apply-templates select="@*|node()|text()|comment()|processing-instruction()" /&gt;<br />    &lt;/xsl:copy&gt;<br />  &lt;/xsl:template&gt;<br /><br />&lt;/xsl:stylesheet&gt;<br /></pre><br />Looks quite simple right? Now when we run the above code, the <i>RSSParser</i> will output an XML snippet to the terminal/console which looks like this:<br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;info&gt;<br />  &lt;title&gt;Jeroen Reijn&lt;/title&gt;<br />  &lt;lastBuildDate&gt;Mon, 21 Mar 2011 22:54:06 +0000&lt;/lastBuildDate&gt;<br />&lt;/info&gt;<br /></pre><br /><h2>Final thoughts</h2>I was able to put this example together in about 20 minutes. That's quite fast if you compare this to the old styled processing of Cocoon. <br />I think the Cocoon team is really far with reaching their goals. Because you are now able to write the processing logic with just some Java, this makes it easy to integrate with any existing Java based framework. <br />I'm curious what else will get into the first official Cocoon 3 release, because it's already quite powerful. From now on I will be using Cocoon 3, when I need to process large (and small) XML files. With the new Java based model it's easy to create a small but powerful processor.<br /><br />For those interested in the source code, you can find the code on <a href="https://github.com/jreijn/cocoon3-demo">GitHub</a>.</div>
