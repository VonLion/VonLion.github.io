---
layout: post
title: "An introduction to Hippo CMS 7 updater modules"
date: 2010-06-10
comments: true
categories:
 - java
 - hippo
---

Once your <a href="http://www.onehippo.org/">Hippo CMS</a> project is in production, there is always the case that you or your customer wants to add extra features to the website or portal. This might mean that the data model has to change.<br />The data model for a piece of content in Hippo CMS is stored based on a JCR nodetype definition.<br />As you might know the editor templates, which are related to the data model, can be edited live in the CMS. When you're done editing the editor templates, you can use the 'Update all content' button to persist the changes in your existing content model. <br />This might be a nice way of doing things during development, but performing such an operation on a live clustered environment can be quite tricky and you might want to do it in a more controlled and tested way.

As of Hippo CMS 7.2 it's possible to perform these changes by writing updater modules in plain Java. In this post I will try to explain the concept of updater modules and will show you how to write these updater modules and use them for updating your data model.<br /><br /><i><b>Note</b>: For those of you reading this post and are using Hippo CMS version 7.8+ this mechanism has changed. From version 7.8 onwards you  can use the Updater Editor to create Groovy based scripts within the CMS  to perform these kind of operations. See the <a href="http://www.onehippo.org/7_8/library/concepts/upgrade/using-the-updater-editor.html" target="_blank">official Hippo CMS documentation</a> page for further information. </i><br /><br /><h2>Writing an Updater module</h2><br />When you start writing an updater module you can start out with the following simple class file:<br /><br /><pre class="brush:java">import org.hippoecm.repository.ext.UpdaterModule;<br />import org.hippoecm.repository.ext.UpdaterContext;<br /><br />public class MyProjectUpdater implements UpdaterModule {<br /><br />    public void register(final UpdaterContext context) {<br />       .....<br />    }<br /><br />}<br /></pre><br />As you can see in the above code snippet the MyProjectUpdater extends the UpdaterModule interface, which requires you to implement the register() method. On your classpath you will need the hippo-ecm-api library, which comes with the Hippo CMS 7 war package or you can get it from the maven 2 repository.<br /><br /><h2>Updaters and versioning</h2><br />Performing such an update on your data model is most of the time specific for the current release of your project. The engine behind the updater modules can be instructed to only trigger certain updater modules if certain requirements (like the version of your project) are met. You can instruct the updater engine to trigger a specific updater module by registering a start tag on the UpdaterContext. In the following example we will:<br /><br /><ul><li>register a unique name for our updater module</li><li>register a start tag for which this updater module should be triggered</li><li>register an end tag to which this version should change once the update was successful</li></ul><br /><pre class="brush:java">import org.hippoecm.repository.ext.UpdaterModule;<br />import org.hippoecm.repository.ext.UpdaterContext;<br /><br />public class MyProjectUpdater implements UpdaterModule {<br /><br />    public void register(final UpdaterContext context) {<br />        context.registerName("myproject-updater-v1-to-v1_1");<br />        context.registerStartTag("myproject-v1");<br />        context.registerEndTag("myproject-v1_1");<br />   }<br />  <br />}<br /></pre><br />In the above updater module we will update our project from version 1 to version 1.1.<br />Our updater module does not do any radical changes so far. It will only change the start version in the repository for our project. You can find the current registered version(s) inside the Hippo repository with the Hippo CMS Console view on the path:<br /><br /><pre>/hippo:configuration/hippo:initialize/@hippo:version.<br /></pre><br />If you don't have a project specific version yet, I would recommend creating one, because it will help you with using these updater modules.<br /><br />Now let's continue with some more interesting stuff.<br /><br /><h2>Visitors</h2><br />You might want to change the data model with some simple operations like: adding a field, removing a field or introducing some new nodetypes. The hippo repository provides several visitors for doing changes inside the repository while performing an update. By default Hippo CMS 7.3 comes with 4 types of visitors. The following diagram shows you the class hierarchy for the ItemVisitor interface.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_hd6Y7yyFK7E/TA-hx6QkNXI/AAAAAAAAAY4/MpeeqjGgZMc/s1600/visitor-diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="196" src="http://1.bp.blogspot.com/_hd6Y7yyFK7E/TA-hx6QkNXI/AAAAAAAAAY4/MpeeqjGgZMc/s640/visitor-diagram.png" width="640" /></a></div><br />As you can see the following visitors are available:<br /><ul><li>NodeTypeVisitor - visits nodes of a specific primary type</li><li>PathVisitor - visits nodes based on their path in the repository</li><li>QueryVisitor - visits nodes found based on a JCR query</li><li>NamespaceVisitor - visits specified namespaces</li></ul><br />Of course you can also write your own visitor if you want, but I guess the provided visitors are the most commonly used.<br /><br /><i>Note: The NamespaceVisitor is a special case and is not supposed to be used in a clustered Hippo setup. If you really need to use it make sure you run the updater on a non-clustered repository node.</i><br /><br /><h2>How to use a visitor in your module</h2>Now that we've seen the available visitors, let's see how we can use them. I think the most common use for updaters is when you need to update your data model without any extra processing involved. Let's say our current datamodel (cnd) version 1.0 looks like this:<br /><br /><pre class="brush:plain">&lt;hippo='http://www.onehippo.org/jcr/hippo/nt/2.0'&gt;<br />&lt;hippostd='http://www.onehippo.org/jcr/hippostd/nt/2.0'&gt;<br />&lt;hippostdpubwf='http://www.onehippo.org/jcr/hippostdpubwf/nt/1.0'&gt;<br />&lt;myproject='http://www.myproject.org/jcr/nt/1.0'&gt;<br /><br />[myproject:basedocument] &gt; hippo:document, hippostdpubwf:document, hippostd:publishableSummary<br /><br />[myproject:news] &gt; myproject:basedocument<br />- myproject:title (string)<br />+ myproject:text (hippostd:html)<br /></pre><br />We want to move to version 1.1, where we added a new subtitle field. The new nodetype defintion now looks like this:<br /><br /><pre class="brush:plain">&lt;hippo='http://www.onehippo.org/jcr/hippo/nt/2.0'&gt;<br />&lt;hippostd='http://www.onehippo.org/jcr/hippostd/nt/2.0'&gt;<br />&lt;hippostdpubwf='http://www.onehippo.org/jcr/hippostdpubwf/nt/1.0'&gt;<br />&lt;myproject='http://www.myproject.org/jcr/nt/1.1'&gt;<br /><br />[myproject:basedocument] &gt; hippo:document, hippostdpubwf:document, hippostd:publishableSummary<br /><br />[myproject:news] &gt; myproject:basedocument<br />- myproject:title (string)<br />- myproject:subtitle (string)<br />+ myproject:text (hippostd:html)<br /></pre><br /><br />Now if we want to update our namespace with an updater module our actual code will look like this:<br /><br /><pre class="brush:java">import java.io.InputStreamReader;<br /><br />import org.hippoecm.repository.ext.UpdaterItemVisitor;<br />import org.hippoecm.repository.ext.UpdaterModule;<br />import org.hippoecm.repository.ext.UpdaterContext;<br /><br />public class MyProjectUpdater implements UpdaterModule {<br /><br />    public void register(final UpdaterContext context) {<br />        context.registerName("myproject-updater-v1-to-v1_1");<br />        context.registerStartTag("myproject-v1");<br />        context.registerEndTag("myproject-v1_1");<br />        <br />        context.registerVisitor(new UpdaterItemVisitor.NamespaceVisitor(context, "myproject", "-",<br />        new InputStreamReader(getClass().getClassLoader().getResourceAsStream("myproject.cnd"))));<br /><br />   }<br />  <br />}<br /></pre><br />The updater module above registers a namespace visitor on the UpdaterContext and the visitor reloads the content nodetype definition (cnd in short) from the classpath and updates the namespace to the new version. This is all you have to do to just bump a namespace from version 1.0 to 1.1.<br /><br />Now if you actually want to change something during the update we can make use of one of the other visitors like the NodeTypeVisitor. Let's say we want to change a certain property of all documents of type 'myproject:news', then this is what the updater might look like:<br /><br /><pre class="brush:java">import java.io.InputStreamReader;<br /><br />import javax.jcr.Node;<br />import javax.jcr.RepositoryException;<br />import javax.jcr.Value;<br /><br />import org.hippoecm.repository.ext.UpdaterItemVisitor;<br />import org.hippoecm.repository.ext.UpdaterModule;<br />import org.hippoecm.repository.ext.UpdaterContext;<br /><br />public class MyProjectUpdater implements UpdaterModule {<br /><br />    public void register(final UpdaterContext context) {<br />        context.registerName("myproject-updater-v1-to-v1_1");<br />        context.registerStartTag("myproject-v1");<br />        context.registerEndTag("myproject-v1_1");<br />        <br />        context.registerVisitor(new UpdaterItemVisitor.NodeTypeVisitor("myproject:news") {<br />            @Override<br />            protected void leaving(Node node, int level) throws RepositoryException {<br />               if (node.hasProperty("myproject:property")) {<br />                   node.setProperty("myproject:property", "new value");<br />               }<br />            } <br />        });<br />   }<br />  <br />}<br /></pre><br />The important part of the updater in this case is that we override the <b>leaving()</b>&nbsp;method, which will be called before the visitor leaves this node and moves on to the next. It will then change the value of a certain property and move on.<br /><br />If you want to see more examples of how to use certain types of visitors please let me know, but I hope that the two examples above can help you get started with writing updater modules. Now let's see how to get the repository to run your updater module.<br /><br /><h2>Adding the updater module to your deployment</h2><br />Now that we've seen how to write an updater module, the next step is to get the repository to run your updater module. The Hippo CMS 7 repository knows about the existence of these updater modules, but you will need to instruct the repository on where they can be found. Making an updater module available to repository is done in the similar fashion as <a href="http://blog.jeroenreijn.com/2009/03/using-daemon-modules-with-hippo-cms-7.html">adding a daemon module to the repository</a>. The location of the updater module needs to be added to the MANIFEST.MF, which will end up in your jar. Maven 2 can help you with achieving this by means of the maven-jar-plugin. See the following plugin configuration from my pom.xml file.<br /><br /><pre class="brush:xml">&lt;plugin&gt;<br />  &lt;groupid&gt;org.apache.maven.plugins&lt;/groupid&gt;<br />  &lt;artifactid&gt;maven-jar-plugin&lt;/artifactid&gt;<br />  &lt;configuration&gt;<br />    &lt;archive&gt;<br />      &lt;manifest&gt;<br />        &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;<br />      &lt;/manifest&gt;<br />      &lt;manifestEntries&gt;<br />        &lt;Hippo-Modules&gt;com.myproject.repository.update.MyProjectUpdater&lt;/Hippo-Modules&gt;<br />      &lt;/manifestEntries&gt;<br />    &lt;/archive&gt;<br />  &lt;/configuration&gt;<br />&lt;/plugin&gt;<br /></pre><br />Now when you add the jar with our updater module to the CMS web application archive and start the CMS, the repository will scan all manifest files for implementations of the UpdaterModule interface. The updater modules will be registered and triggered when needed. <br /><br />The updater modules are quite powerful and it's great that you can test them on your test environment, so you can make sure that when you perform an update in production it will succeed.<br /><br /><b>References</b><br /><ul><li><a href="http://www.onehippo.org/7_7/library/concepts/upgrade/dtap.html">More information about moving changes through a DTAP environment</a></li></ul>
